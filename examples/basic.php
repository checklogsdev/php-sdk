<?php

require_once __DIR__ . '/../vendor/autoload.php';

use CheckLogs\CheckLogsLogger;
use CheckLogs\CheckLogsClient;
use CheckLogs\LogLevel;
use CheckLogs\ApiError;
use CheckLogs\NetworkError;
use CheckLogs\ValidationError;
use function CheckLogs\{createLogger, quickLog, quickError};

// Configuration
$apiKey = 'a0229737f9ed24719fc405916e97eaadd7671dfb092aeb3fe337e38f8c146678';

echo "üöÄ === TEST COMPLET CHECKLOGS PHP SDK ===\n\n";

// ========================================
// TEST 1: INITIALISATION
// ========================================
echo "üìã 1. Test d'initialisation...\n";

try {
    $logger = new CheckLogsLogger($apiKey, [
        'source' => 'test-sdk-complet',
        'consoleOutput' => true,
        'defaultContext' => [
            'test_suite' => 'complete_test',
            'php_version' => PHP_VERSION
        ]
    ]);
    echo "   ‚úÖ Logger cr√©√© avec succ√®s\n";
} catch (Exception $e) {
    echo "   ‚ùå Erreur cr√©ation logger: " . $e->getMessage() . "\n";
    exit(1);
}

// ========================================
// TEST 2: LOGS BASIQUES
// ========================================
echo "\nüìù 2. Test des niveaux de logs...\n";

$logTests = [
    ['method' => 'debug', 'message' => 'Message de debug pour test'],
    ['method' => 'info', 'message' => 'Message d\'information'],
    ['method' => 'warning', 'message' => 'Message d\'avertissement'],
    ['method' => 'error', 'message' => 'Message d\'erreur de test'],
    ['method' => 'critical', 'message' => 'Message critique de test']
];

foreach ($logTests as $test) {
    try {
        $result = $logger->{$test['method']}($test['message'], [
            'test_type' => 'level_test',
            'level' => $test['method']
        ]);
        
        if ($result !== null) {
            echo "   ‚úÖ {$test['method']}: Log envoy√© avec succ√®s\n";
        } else {
            echo "   ‚ö†Ô∏è  {$test['method']}: Log non envoy√© (mode silent ou filtr√©)\n";
        }
        
        // Attendre un peu entre les logs
        usleep(100000); // 100ms
        
    } catch (Exception $e) {
        echo "   ‚ùå {$test['method']}: Erreur - " . $e->getMessage() . "\n";
    }
}

// ========================================
// TEST 3: LOGS AVEC CONTEXTE RICHE
// ========================================
echo "\nüîç 3. Test avec contexte riche...\n";

try {
    $result = $logger->info('Connexion utilisateur avec contexte riche', [
        'user_id' => 12345,
        'email' => 'test@example.com',
        'ip_address' => '192.168.1.100',
        'user_agent' => 'CheckLogs-PHP-SDK-Test/1.0',
        'session_data' => [
            'session_id' => 'sess_' . uniqid(),
            'login_time' => date('c'),
            'permissions' => ['read', 'write']
        ],
        'metadata' => [
            'source_test' => true,
            'test_timestamp' => microtime(true)
        ]
    ]);
    
    if ($result !== null) {
        echo "   ‚úÖ Log avec contexte riche envoy√©\n";
    } else {
        echo "   ‚ö†Ô∏è  Log avec contexte non envoy√©\n";
    }
} catch (Exception $e) {
    echo "   ‚ùå Erreur contexte riche: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 4: CHILD LOGGERS
// ========================================
echo "\nüë∂ 4. Test des child loggers...\n";

try {
    // Logger principal pour l'authentification
    $authLogger = $logger->child([
        'module' => 'authentication',
        'component' => 'login_service'
    ]);
    
    // Logger pour une session sp√©cifique
    $sessionLogger = $authLogger->child([
        'session_id' => 'sess_test_' . uniqid(),
        'user_id' => 98765
    ]);
    
    $authLogger->info('Module d\'authentification initialis√©');
    $sessionLogger->info('Session utilisateur cr√©√©e');
    $sessionLogger->warning('Tentative de connexion avec mot de passe incorrect');
    $sessionLogger->info('Connexion r√©ussie apr√®s 2√®me tentative');
    
    echo "   ‚úÖ Child loggers test√©s avec succ√®s\n";
} catch (Exception $e) {
    echo "   ‚ùå Erreur child loggers: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 5: TIMER ET PERFORMANCE
// ========================================
echo "\n‚è±Ô∏è  5. Test du syst√®me de timer...\n";

try {
    // Test timer simple
    $timer1 = $logger->time('operation_test', 'D√©but op√©ration de test');
    usleep(150000); // 150ms
    $duration1 = $timer1();
    echo "   ‚úÖ Timer simple: {$duration1}ms\n";
    
    // Test timer imbriqu√©s
    $timer2 = $logger->time('operation_complexe', 'D√©but op√©ration complexe');
    
    $subTimer = $logger->time('sub_operation', 'Sous-op√©ration');
    usleep(75000); // 75ms
    $subDuration = $subTimer();
    
    usleep(100000); // 100ms de plus
    $duration2 = $timer2();
    
    echo "   ‚úÖ Timer complexe: {$duration2}ms (dont sous-op√©ration: {$subDuration}ms)\n";
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur timer: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 6: FONCTIONS UTILITAIRES
// ========================================
echo "\nüõ†Ô∏è  6. Test des fonctions utilitaires...\n";

try {
    // Test createLogger
    $utilityLogger = createLogger($apiKey, [
        'source' => 'utility-test',
        'consoleOutput' => false
    ]);
    $utilityLogger->info('Test fonction createLogger');
    echo "   ‚úÖ createLogger fonctionne\n";
    
    // Test quickLog
    quickLog($apiKey, 'Test quickLog function', ['quick' => true]);
    echo "   ‚úÖ quickLog fonctionne\n";
    
    // Test quickError
    quickError($apiKey, 'Test quickError function', ['error_code' => 'TEST_ERROR']);
    echo "   ‚úÖ quickError fonctionne\n";
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur fonctions utilitaires: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 7: GESTION D'ERREURS
// ========================================
echo "\nüö® 7. Test de la gestion d'erreurs...\n";

// Test avec cl√© API invalide
try {
    $badLogger = new CheckLogsLogger('invalid-api-key-test', [
        'consoleOutput' => false,
        'timeout' => 2000
    ]);
    $result = $badLogger->info('Ce log ne devrait pas passer');
    echo "   ‚ö†Ô∏è  Test cl√© invalide: Log ignor√© (pas d'exception lev√©e)\n";
} catch (ApiError $e) {
    echo "   ‚úÖ Test cl√© invalide: ApiError captur√©e - " . $e->getMessage() . "\n";
} catch (Exception $e) {
    echo "   ‚ö†Ô∏è  Test cl√© invalide: Exception autre - " . $e->getMessage() . "\n";
}

// Test validation des donn√©es
try {
    $logger->log([
        'message' => str_repeat('x', 2000), // Message trop long
        'level' => 'invalid_level'
    ]);
    echo "   ‚ùå Validation: Devrait √©chouer\n";
} catch (ValidationError $e) {
    echo "   ‚úÖ Validation: ValidationError captur√©e - " . $e->getMessage() . "\n";
}

// ========================================
// TEST 8: CLIENT DIRECT
// ========================================
echo "\nüîå 8. Test du client direct...\n";

try {
    $client = new CheckLogsClient($apiKey);
    
    // Test envoi log direct
    $result = $client->log([
        'message' => 'Test via client direct',
        'level' => LogLevel::INFO,
        'context' => [
            'client_test' => true,
            'timestamp' => date('c')
        ]
    ]);
    
    if ($result !== null) {
        echo "   ‚úÖ Client direct: Log envoy√©\n";
    } else {
        echo "   ‚ö†Ô∏è  Client direct: Pas de r√©ponse\n";
    }
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur client direct: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 9: R√âCUP√âRATION DE LOGS
// ========================================
echo "\nüìÑ 9. Test r√©cup√©ration des logs...\n";

try {
    // Attendre un peu pour que les logs soient trait√©s
    sleep(1);
    
    $logs = $logger->getLogs([
        'limit' => 5,
        'level' => 'info'
    ]);
    
    if ($logs !== null && isset($logs['data']['logs'])) {
        $count = count($logs['data']['logs']);
        echo "   ‚úÖ R√©cup√©ration: {$count} logs r√©cup√©r√©s\n";
        
        if ($count > 0) {
            $latestLog = $logs['data']['logs'][0];
            echo "   üìù Dernier log: " . ($latestLog['message'] ?? 'Pas de message') . "\n";
        }
    } else {
        echo "   ‚ö†Ô∏è  R√©cup√©ration: Aucun log ou structure inattendue\n";
    }
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur r√©cup√©ration: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 10: STATISTIQUES
// ========================================
echo "\nüìä 10. Test des statistiques...\n";

try {
    $stats = $logger->getStats();
    
    if ($stats !== null && isset($stats['data'])) {
        $data = $stats['data'];
        echo "   ‚úÖ Statistiques r√©cup√©r√©es\n";
        echo "   üìà Total logs: " . ($data['total_logs'] ?? 'N/A') . "\n";
        echo "   üìÖ Logs aujourd'hui: " . ($data['logs_today'] ?? 'N/A') . "\n";
        
        if (isset($data['stats_by_level'])) {
            echo "   üìä Par niveau:\n";
            foreach ($data['stats_by_level'] as $stat) {
                echo "      - {$stat['level']}: {$stat['count']}\n";
            }
        }
    } else {
        echo "   ‚ö†Ô∏è  Statistiques: Structure inattendue ou vide\n";
    }
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur statistiques: " . $e->getMessage() . "\n";
}

// ========================================
// TEST 11: FLUSH ET NETTOYAGE
// ========================================
echo "\nüßπ 11. Test flush et nettoyage...\n";

try {
    // V√©rifier la queue de retry
    $queueStatus = $logger->getRetryQueueStatus();
    echo "   üìã Queue status: " . $queueStatus['count'] . " √©l√©ments\n";
    
    // Flush les logs en attente
    $flushResult = $logger->flush(5000);
    echo "   " . ($flushResult ? "‚úÖ" : "‚ö†Ô∏è") . " Flush: " . ($flushResult ? "R√©ussi" : "Timeout ou √©chec") . "\n";
    
    // Nettoyer la queue
    $logger->clearRetryQueue();
    echo "   üßπ Queue nettoy√©e\n";
    
} catch (Exception $e) {
    echo "   ‚ùå Erreur flush: " . $e->getMessage() . "\n";
}

// ========================================
// R√âSUM√â FINAL
// ========================================
echo "\nüéØ === R√âSUM√â DU TEST ===\n";

// Log de fin avec r√©sum√©
$logger->info('Tests du SDK CheckLogs termin√©s', [
    'test_suite' => 'complete_test',
    'php_version' => PHP_VERSION,
    'sdk_version' => '1.0.0',
    'timestamp_end' => date('c'),
    'test_status' => 'completed'
]);

echo "\n‚ú® Tests termin√©s ! V√©rifiez vos logs sur CheckLogs.dev\n";
echo "üîó URL: https://checklogs.dev\n";
echo "üîë API Key utilis√©e: " . substr($apiKey, 0, 8) . "...\n";

// Informations de debug
echo "\nüîß Informations de debug:\n";
echo "   - PHP Version: " . PHP_VERSION . "\n";
echo "   - Guzzle install√©: " . (class_exists('GuzzleHttp\\Client') ? 'Oui' : 'Non') . "\n";
echo "   - Extensions JSON: " . (extension_loaded('json') ? 'Oui' : 'Non') . "\n";
echo "   - Extensions cURL: " . (extension_loaded('curl') ? 'Oui' : 'Non') . "\n";
echo "   - Limite m√©moire: " . ini_get('memory_limit') . "\n";
echo "   - Utilisation m√©moire: " . round(memory_get_usage(true) / 1024 / 1024, 2) . " MB\n";

echo "\nüöÄ SDK CheckLogs PHP pr√™t pour la production !\n";